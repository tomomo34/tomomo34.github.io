<!DOCTYPE html> 
<html>
    <head>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.0/css/bulma.min.css">
        <link rel="icon" type="image/x-icon" href="/images/icon.ico">
        <meta charset="UTF-8">
   </head>
   <style>
    body{
        padding:10px;
    }
   </style>
<body>
<div class="content">
    <h1>Jak tahle stranka funguje</h1>
    <p>Tahle stranka se sklada z nekolika javascript 
    codu nejpodstatnejsim z nich je js ktere resi end to end sifrovani.
    Jde o code snippet z githubu ktery je stazeny vzdalene pres esm.sh jako js modul
ak ktery assinchronne resi end to end sifrovani</p>
<blockquote>
    Vygeneru je severejny a privatni klic const cat = new E2EE();
    const dog = new E2EE();
    
    await cat.generateKeyPair();
    await dog.generateKeyPair();
    
    const catPublicKey = await cat.exportPublicKey();
    const dogPublicKey = await dog.exportPublicKey();
    
    v mem ppripade se generuje jen jedna strana klice a ta se exportuje druhe strane k pouziti
    tato knihovna uklada privatni klice automaticky pro danou instanci 

    await cat.setRemotePublicKey(dogPublicKey);
    await dog.setRemotePublicKey(catPublicKey);

    druhy klient si public klic prijme a nastavi ho jako svuj. Timhle klicem zasifruje svou zpravu a
    druhy klient ji muze prijimat
    
    const encryptedCatSays = await cat.encrypt(catSays);
const encryptedDogSays = await dog.encrypt(dogSays);

const decryptedDogSays = await cat.decrypt(encryptedDogSays);
const decryptedCatSays = await dog.decrypt(encryptedCatSays);
    data se na jedne strane zasifruji ulozi do const a po simulovane ceste siti se 
    zase desifruji. json encrypted_x_says je sifrovany a lze ho bezpecne prenaset klidne
    i v plaintextu protoze se jedna pouze o nahodne znaky kdyz nezname klic

</blockquote>
</div>
</body>
</html>